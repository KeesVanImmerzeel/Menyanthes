hm$xd$RATIO <- NULL
# Laat waarnemingen van filters eruit als er te weinig waarnemingen zijn.
nmin <- 52/2
n <- hm$xd %>% dplyr::group_by(NAME,FILTER) %>% dplyr::summarise(NOBS=dplyr::n())
hm$xm %<>% dplyr::left_join(n) %>% dplyr::filter(NOBS < nmin)
hm$xd %<>% dplyr::left_join(n) %>% dplyr::filter(NOBS < nmin)
hm$xm$NOBS <- NULL
hm$xd$NOBS <- NULL
head(hm$xm)
hm <- menyanthes::hm_rbind(t1,t2)
hm %<>% menyanthes::hm_rbind(t3)
hm %<>% menyanthes::hm_rbind(t4)
# Kleine correctie
hm$xm[which(hm$xm$FILTER>10),]$FILTER <- 3
hm$xd[which(hm$xd$FILTER>10),]$FILTER <- 3
# Filter HydroMonitor ObservationWell data on year.
hm %<>% hm_filter_on_year(minyear = 2001, maxyear = 2020)
# Voeg percentile GxG waarden toe aan meta data van peilbuisgegevens
hm$xm <- hm_calc_gxg(hm)
# Laat waarnemingen van filters eruit waarin er 'gaten' lijken te zitten.
# Ratio's (# observations in filter) / (average # of observations in monitoring well) < 0.75
rmin <- 0.75
r <- nr_obs_ratio(hm)
hm$xm %<>% dplyr::left_join(r) %>% dplyr::filter(RATIO > rmin)
hm$xd %<>% dplyr::left_join(r) %>% dplyr::filter(RATIO > rmin)
hm$xm$RATIO <- NULL
hm$xd$RATIO <- NULL
head(hm$xm)
# Laat waarnemingen van filters eruit als er te weinig waarnemingen zijn.
nmin <- 52/2
n <- hm$xd %>% dplyr::group_by(NAME,FILTER) %>% dplyr::summarise(NOBS=dplyr::n())
n
hm$xm %<>% dplyr::left_join(n) %>% dplyr::filter(NOBS > nmin)
hm$xd %<>% dplyr::left_join(n) %>% dplyr::filter(NOBS > nmin)
hm$xm$NOBS <- NULL
hm$xd$NOBS <- NULL
# Schrijf (gefilterde) HydroMonitor ObservationWell data.
saveRDS(hm,"t.rd")
x <- hm$xm
# Maak een spatial object van de gegevens van de peilbuizen
sp::coordinates(x) <- ~X+Y
proj4string(x) <- crsAfoort
# Lees shape om gegevens te selecteren
filename <- "../../../../GIS/SWECO/SkyTem_Boundary/SkyTem_Boundary.shp"
p <- raster::shapefile(filename)
# Intersects point and polygon feature classes and adds polygon attributes to points.
x_clipped <- point.in.poly(x, p)
# Subset point feature
x_clipped <- x_clipped[!is.na(x_clipped$id), ]
head(x_clipped@data)
# Write resulting point shape
raster::shapefile(x=x_clipped, filename="Peilbuizen_provDrenthe_in_Sky_Tem.shp", overwrite = TRUE)
head(x_clipped@data)
# Filter ook in hm op de clip
hm$xm %<>% intersect( x_clipped@data )
head(hm$xm)
hm <- menyanthes::hm_rbind(t1,t2)
hm %<>% menyanthes::hm_rbind(t3)
hm %<>% menyanthes::hm_rbind(t4)
# Kleine correctie
hm$xm[which(hm$xm$FILTER>10),]$FILTER <- 3
hm$xd[which(hm$xd$FILTER>10),]$FILTER <- 3
# Filter HydroMonitor ObservationWell data on year.
hm %<>% hm_filter_on_year(minyear = 2001, maxyear = 2020)
# Voeg percentile GxG waarden toe aan meta data van peilbuisgegevens
hm$xm <- hm_calc_gxg(hm)
# Laat waarnemingen van filters eruit waarin er 'gaten' lijken te zitten.
# Ratio's (# observations in filter) / (average # of observations in monitoring well) < 0.75
rmin <- 0.75
r <- nr_obs_ratio(hm)
hm$xm %<>% dplyr::left_join(r) %>% dplyr::filter(RATIO > rmin)
hm$xd %<>% dplyr::left_join(r) %>% dplyr::filter(RATIO > rmin)
hm$xm$RATIO <- NULL
hm$xd$RATIO <- NULL
# Laat waarnemingen van filters eruit als er te weinig waarnemingen zijn.
nmin <- 52/2
n <- hm$xd %>% dplyr::group_by(NAME,FILTER) %>% dplyr::summarise(NOBS=dplyr::n())
hm$xm %<>% dplyr::left_join(n) %>% dplyr::filter(NOBS > nmin)
hm$xd %<>% dplyr::left_join(n) %>% dplyr::filter(NOBS > nmin)
hm$xm$NOBS <- NULL
hm$xd$NOBS <- NULL
# Ga alleen verder met de meta data van de peilbuisgegevens
x <- hm$xm
# Maak een spatial object van de gegevens van de peilbuizen
sp::coordinates(x) <- ~X+Y
proj4string(x) <- crsAfoort
# Lees shape om gegevens te selecteren
filename <- "../../../../GIS/SWECO/SkyTem_Boundary/SkyTem_Boundary.shp"
p <- raster::shapefile(filename)
# Intersects point and polygon feature classes and adds polygon attributes to points.
x_clipped <- point.in.poly(x, p)
# Subset point feature
x_clipped <- x_clipped[!is.na(x_clipped$id), ]
str(x_clipped@data)
# Filter ook in hm op de clip
test <- dplyr::intersect(hm$xm, x_clipped@data )
str(hm$xm)
# Filter ook in hm op de clip
test <- dplyr::semi_join(hm$xm, x_clipped@data, by=c("NAME","FILTER") )
head(test)
hm <- menyanthes::hm_rbind(t1,t2)
hm %<>% menyanthes::hm_rbind(t3)
hm %<>% menyanthes::hm_rbind(t4)
# Kleine correctie
hm$xm[which(hm$xm$FILTER>10),]$FILTER <- 3
hm$xd[which(hm$xd$FILTER>10),]$FILTER <- 3
# Filter HydroMonitor ObservationWell data on year.
hm %<>% hm_filter_on_year(minyear = 2001, maxyear = 2020)
# Voeg percentile GxG waarden toe aan meta data van peilbuisgegevens
hm$xm <- hm_calc_gxg(hm)
# Laat waarnemingen van filters eruit waarin er 'gaten' lijken te zitten.
# Ratio's (# observations in filter) / (average # of observations in monitoring well) < 0.75
rmin <- 0.75
r <- nr_obs_ratio(hm)
hm$xm %<>% dplyr::left_join(r) %>% dplyr::filter(RATIO > rmin)
hm$xd %<>% dplyr::left_join(r) %>% dplyr::filter(RATIO > rmin)
hm$xm$RATIO <- NULL
hm$xd$RATIO <- NULL
# Laat waarnemingen van filters eruit als er te weinig waarnemingen zijn.
nmin <- 52/2
n <- hm$xd %>% dplyr::group_by(NAME,FILTER) %>% dplyr::summarise(NOBS=dplyr::n())
hm$xm %<>% dplyr::left_join(n) %>% dplyr::filter(NOBS > nmin)
hm$xd %<>% dplyr::left_join(n) %>% dplyr::filter(NOBS > nmin)
hm$xm$NOBS <- NULL
hm$xd$NOBS <- NULL
# Ga alleen verder met de meta data van de peilbuisgegevens
x <- hm$xm
# Maak een spatial object van de gegevens van de peilbuizen
sp::coordinates(x) <- ~X+Y
proj4string(x) <- crsAfoort
# Lees shape om gegevens te selecteren
filename <- "../../../../GIS/SWECO/SkyTem_Boundary/SkyTem_Boundary.shp"
p <- raster::shapefile(filename)
# Intersects point and polygon feature classes and adds polygon attributes to points.
x_clipped <- point.in.poly(x, p)
# Subset point feature
x_clipped <- x_clipped[!is.na(x_clipped$id), ]
# Write resulting point shape
raster::shapefile(x=x_clipped, filename="Peilbuizen_provDrenthe_in_Sky_Tem.shp", overwrite = TRUE)
# Filter ook in hm op de clip
hm$xm %<>% dplyr::semi_join(x_clipped@data, by=c("NAME","FILTER") )
hm$xd %<>% dplyr::semi_join(x_clipped@data, by=c("NAME","FILTER") )
head(hm$xm)
head(hm$xd)
p <- raster::shapefile("Peilbuizen_provDrenthe_in_Sky_Tem.shp")
e <- extent(p)
e <- extent(236400,248600,543200,564600)
brk25 <- brick("brk25.grd")
brk50 <- brick("brk50.grd")
brk100 <- brick("brk100.grd")
topF <- p@data$TOP
botF <- p@data$BOT
get_rl_code <- function(topF, botF, topL, botL) {
rl_code <- NA
if ((!is.na(topL)) & (botF > topL)) {
rl_code <- 1
} else if ((!is.na(botL)) & (topF < botL)) {
rl_code <- -1
} else if ((!is.na(topL)) & (!is.na(botL)))    {
rl_code <- 0
}
return(rl_code)
}
# 25x25m resolution rasters
df <- raster::extract(brk25, p, df = TRUE)
p@data$kl_TNO <-
mapply(
get_rl_code,
p@data$TOP,
p@data$BOT,
df$kl_TNO_top,
df$kl_TNO_bot,
USE.NAMES = FALSE,
SIMPLIFY = TRUE
)
# 50x50m resolution rasters
df <- raster::extract(brk50, p, df = TRUE)
p@data$pk1_2_ST_Assen <- #p1_2_ST
mapply(
get_rl_code,
p@data$TOP,
p@data$BOT,
df$pk1_2_ST_Assen_top,
df$pk1_2_ST_Assen_bot,
USE.NAMES = FALSE,
SIMPLIFY = TRUE
)
p@data$pk1_ST <-
mapply(
get_rl_code,
p@data$TOP,
p@data$BOT,
df$pk1_ST_top,
df$pk1_ST_bot,
USE.NAMES = FALSE,
SIMPLIFY = TRUE
)
p@data$pz_ST <-
mapply(
get_rl_code,
p@data$TOP,
p@data$BOT,
df$pz_ST_top,
df$pz_ST_bot,
USE.NAMES = FALSE,
SIMPLIFY = TRUE
)
# 100x100m resolution rasters
df <- raster::extract(brk100, p, df = TRUE)
p@data$pz1_REG <-
mapply(
get_rl_code,
p@data$TOP,
p@data$BOT,
df$pz1_REG_top,
df$pz1_REG_bot,
USE.NAMES = FALSE,
SIMPLIFY = TRUE
)
p@data$pk1_REG <-
mapply(
get_rl_code,
p@data$TOP,
p@data$BOT,
df$pk1_REG_top,
df$pk1_REG_bot,
USE.NAMES = FALSE,
SIMPLIFY = TRUE
)
p@data$pz2_REG <-
mapply(
get_rl_code,
p@data$TOP,
p@data$BOT,
df$pz2_REG_top,
df$pz2_REG_bot,
USE.NAMES = FALSE,
SIMPLIFY = TRUE
)
p@data$pk2_REG <-
mapply(
get_rl_code,
p@data$TOP,
p@data$BOT,
df$pk2_REG_top,
df$pk2_REG_bot,
USE.NAMES = FALSE,
SIMPLIFY = TRUE
)
p@data$pz3_REG <-
mapply(
get_rl_code,
p@data$TOP,
p@data$BOT,
df$pz3_REG_top,
df$pz3_REG_bot,
USE.NAMES = FALSE,
SIMPLIFY = TRUE
)
# Write resulting point shape
raster::shapefile(x=p, filename="Peilbuizen_provDrenthe_in_Sky_Tem_annotated.shp", overwrite = TRUE)
# Read shapefile
p <- raster::shapefile("Peilbuizen_provDrenthe_in_Sky_Tem_annotated.shp")
head(p@data)
p <- raster::shapefile("Peilbuizen_provDrenthe_in_Sky_Tem_annotated.shp")
e <- extent(p)
e <- extent(236400,248600,543200,564600)
get_dGG_over_layers <- function(pb_name, x) {
xd <- x %>% dplyr::filter(NAME == pb_name)
n <- nrow(xd) # aantal filters van de peilbuis met de naam pb_name
d_GG_pk_ST <-
NA # Stijghoogteverschil GG over Peelo kleivolgens SkyTem
d_GG_pz_ST <-
NA # Stijghoogteverschil in Peelo zand volgens SkyTem
d_GG_pk1_REG <-
NA # Stijghoogteverschil over Peelo klei 1 volgens Regis.
d_GG_pk2_REG <-
NA # Stijghoogteverschil over Peelo klei 2 volgens Regis.
d_GG_pz1_REG <-
NA # Stijghoogteverschil in Peelo zand 1 volgens Regis.
d_GG_pz2_REG <-
NA # Stijghoogteverschil in Peelo zand 2 volgens Regis.
d_GG_pz3_REG <-
NA # Stijghoogteverschil in Peelo klei 3 volgens Regis.
if (n > 1) {
# Verwijder waarnemingen van filters boven de keileem
i <- which(xd$kl_TNO > 0)
if (length(i) > 0) {
xd <- xd[-c(i),]
}
# Bereken stijghoogteverschil GG over Peelo volgens SkyTem
i <- which((xd$p1_2_ST > 0) | (xd$pk1_ST > 0))
if (length(i) > 0) {
j <- which((xd$p1_2_ST < 0) | (xd$pk1_ST < 0))
if (length(j) > 0) {
d_GG_pk_ST <- xd$GG[max(i)] - xd$GG[min(j)]
}
}
# Bereken stijghoogteverschil over Peelo zand vlgs SkyTem
i <- which(xd$pz_ST == 0)
if (length(i) > 1) {
d_GG_pz_ST <- xd$GG[max(i)] - xd$GG[min(i)]
}
# Bereken Stijghoogteverschil over Peelo klei 1 volgens Regis.
i <- which(xd$pk1_REG > 0)
if (length(i) > 0) {
j <- which(xd$pk1_REG < 0)
if (length(j) > 0) {
d_GG_pk1_REG <- xd$GG[max(i)] - xd$GG[min(j)]
}
}
# Bereken stijghoogteverschil over Peelo klei 2 volgens Regis
i <- which(xd$pk2_REG > 0)
if (length(i) > 0) {
j <- which(xd$pk2_REG < 0)
if (length(j) > 0) {
d_GG_pk2_REG <- xd$GG[max(i)] - xd$GG[min(j)]
}
}
# Bereken stijghoogteverschil over Peelo zand 1 vlgs Regis
i <- which(xd$pz1_REG == 0)
if (length(i) > 1) {
d_GG_pz1_REG <- xd$GG[max(i)] - xd$GG[min(i)]
}
# Bereken stijghoogteverschil over Peelo zand 2 vlgs Regis
i <- which(xd$pz2_REG == 0)
if (length(i) > 1) {
d_GG_pz2_REG <- xd$GG[max(i)] - xd$GG[min(i)]
}
# Bereken stijghoogteverschil over Peelo zand 3 vlgs Regis
i <- which(xd$pz3_REG == 0)
if (length(i) > 1) {
d_GG_pz3_REG <- xd$GG[max(i)] - xd$GG[min(i)]
}
} # twee of meer filters
res <-
data.frame(
d_GG_pk_ST = d_GG_pk_ST,
d_GG_pz_ST = d_GG_pz_ST,
d_GG_pk1_REG = d_GG_pk1_REG, #d_GG_pk1_R
d_GG_pk2_REG = d_GG_pk2_REG, #d_GG_pk2_R
d_GG_pz1_REG = d_GG_pz1_REG, #d_GG_pz1_R
d_GG_pz2_REG = d_GG_pz2_REG, #d_GG_pz2_R
d_GG_pz3_REG = d_GG_pz3_REG
)
return(res)
}
pb_names <- unique(p@data$NAME) %>% sort() %>% as.array()
res <- apply(pb_names,1,get_dGG_over_layers,x=p@data) %>% Reduce(rbind,.)
res$NAME <- pb_names
df <- suppressWarnings( dplyr::left_join(p@data, res) )
xy <- p@coords %>% as.data.frame()
df$X <- xy$coords.x1
df$Y <- xy$coords.x2
cnames <- c("NAME", "X", "Y", "d_GG_pk_ST","d_GG_pz_ST", "d_GG_pk1_REG", "d_GG_pk2_REG", "d_GG_pz1_REG", "d_GG_pz2_REG", "d_GG_pz3_REG")
df <-df[,cnames] %>% dplyr::distinct()
# Maak shape file van het resultaat.
sp::coordinates(df) <- ~ X + Y   # Voeg coordinaten toe aan dataframe
proj4string(df) <- crsAfoort
# Write resulting point shape
raster::shapefile(x=df, filename="dh_over_layers_Peilbuizen_provDrenthe_in_Sky_Tem.shp", overwrite = TRUE)
zand_van_tot <- function(pb_name, x) {
print(pb_name)
xd <- x %>% dplyr::filter(NAME == pb_name)
van_i <- NA
tot_i <- NA
i <-
which(!(xd$GRONDSOORT == "Zand" |
xd$GRONDSOORT == "Grind")) # i: index van bodemlagen niet gelijk aan zand/grind
if (length(i) == 0) {
# Alleen maar zand of grind
van_i <- 1
tot_i <- length(xd)
} else if (length(i) != nrow(xd)) {
# Als niet alle bodemlagen wat anders bevatten dan zand/grind
j <-
dplyr::lead(i) == (i + 1) # TRUE als lagen na i ook niet gelijk aan zand/grind
van_i <- i[which((j == FALSE) | (is.na(j)))] + 1
van_i <- van_i[van_i <= nrow(xd)]
i <- which(xd$GRONDSOORT == "Zand" | xd$GRONDSOORT == "Grind")
if (length(i) != 0) {
if (i[1] == 1) {
van_i <- c(1, van_i)
}
j <- dplyr::lead(i) == (i + 1)
tot_i <- i[which((j == FALSE) | (is.na(j)))]
tot_i <- tot_i[tot_i <= nrow(xd)]
}
}
res <- data.frame(NAME = pb_name,
X = xd$X[van_i],
Y = xd$Y[van_i],
VAN = xd$VAN[van_i],
TOT = xd$TOT[tot_i])
return(res)
}
lees_boring_csv <- function(fname) {
x <-
read.csv(
fname,
header = TRUE,
dec = ",",
sep = ";",
blank.lines.skip = TRUE,
stringsAsFactors = FALSE
)
x %<>% .[,-c(5:17, 21:26)]
colnames(x) <-
c("NAME", "X", "Y", "MV",
"VAN",
"TOT",
"GRONDSOORT")
x$GRONDSOORT %<>% trim()
x %<>% dplyr::filter(!is.na(MV))
x %<>% dplyr::filter(!is.na(VAN))
x %<>% dplyr::filter(!is.na(TOT))
x %<>% dplyr::filter(!is.na(GRONDSOORT))
x$X %<>% as.numeric()
x$Y %<>% as.numeric()
x$MV %<>% as.numeric()
invalid_name <- x$NAME[grep("-[0-9][0-9]$",x$NAME)] # Filter namen xxx_01 etc eruit (dubbele informatie)
x %<>% dplyr::filter(!NAME %in% invalid_name)
x$VAN <- x$MV - x$VAN
x$TOT <- x$MV - x$TOT
return(x)
}
fname <- "Topsoil_boring"
x <- lees_boring_csv(fname)
# Geef VAN / TOT waarden van de niveau's waar in de boorbeschrijving zand voorkomt van peilbuis pb_name.
pb_names <- unique(x$NAME) %>% sort() %>% as.array()
x <- apply(pb_names,1,zand_van_tot,x=x) %>% Reduce(rbind,.)
# Read shapefile van de peilbuizen met stijghoogte gegevens
p <- raster::shapefile("Peilbuizen_provDrenthe_in_Sky_Tem.shp")
# Combineer stijghoogtegegevens (p@data) met boorgegevens (x) --> data.frame "df"
df <- dplyr::inner_join(p@data,x)
str(df)
df$RL <- mapply(get_rl_code, df$TOP, df$BOT, df$VAN, df$TOT, SIMPLIFY = TRUE, USE.NAMES=FALSE)
# Bereken stijghoogteverschil tussen eerste en laatste filter in zandlagen van peilbuis "pb_name".
# df: data.frame met stijghoogtegegevens en boorgegevens (zie hierboven), met code "RL toegevoegd" en gefilterd op
# filters die in het zand liggen
get_dGG_in_sand <- function( pb_name, df ){
print(pb_name)
X <- NA
Y <- NA
F1_SND <- NA
F2_SND <- NA
D_GG_SND <- NA
xd <- df %>% dplyr::filter(NAME == pb_name)
n <- nrow(xd)
if (!is.na(n) & n>1) {
F1_SND <- xd$FILTER[1]
F2_SND <- xd$FILTER[n]
D_GG_SND <- xd$GG[1] - xd$GG[n]
}
res <- data.frame(NAME=pb_name,X=xd$X[1], Y=xd$Y[1], F1_SND=F1_SND,F2_SND=F2_SND,D_GG_SND=D_GG_SND)
return(res)
}
# Bereken voor alle peilbuizen de stijghoogteverschillen tussen eerste en laatste filter in zandlagen van peilbuis "pb_name".
# (Zie function "get_dGG_in_sand").
# Selecteer eerst de filters die geheel in een zandlaag liggen (RL==0).
df %<>% dplyr::filter(RL==0)
pb_names <- unique(df$NAME) %>% sort() %>% as.array()
res <- apply(pb_names,1,get_dGG_in_sand,df=df) %>% Reduce(rbind,.)
# Verwijder in het resultaat de records waar geen stijghoogteverschil berekend kon worden (aantal filters < 2).
nok <- is.na(res$D_GG_SND)
res <- res[!nok,]
# Maak shape file van het resultaat.
sp::coordinates(res) <- ~ X + Y   # Voeg coordinaten toe aan dataframe
proj4string(res) <- crsAfoort
# Write resulting point shape
raster::shapefile(x=res, filename="dh_over_sand_layers_Peilbuizen_provDrenthe_in_Sky_Tem.shp", overwrite = TRUE)
plot(res)
head(res@data)
library(devtools)
load_all()
fname <- system.file("extdata","export_data_menyanthes.csv",package="menyanthes")
hm <- hm_read_export_csv( fname )
str(hm$xd)
hm$xd %<>% dplyr::distinct(NAME,FILTER,DATE, .keep_all = TRUE)
#Verwijder peilbuizen uit meta data waar geen stijghoogten bekend zijn in de gefilterde stijghoogte gegevens
hm$xm %<>% dplyr::semi_join(unique(hm$xd[,c('NAME','FILTER')]))
head(hm$xm,20)
head(hm$xd,20)
document()
document()
library(menyanthes)
document()
load_all()
hm_clean <- hm_rm_fltrs_with_no_obs( hm )
str(hm$xm)
str(hm$xd)
hm <- hm_read_export_csv( fname )
load_all()
hm_filtered <- hm_filter_on_year( hm, minyear=2000)
load_all()
#Verwijder peilbuizen uit meta data waar geen stijghoogten bekend zijn in de gefilterde stijghoogte gegevens
hm %<>% hm_rm_fltrs_with_no_obs()
hm$xd
hm_clean <- hm_rm_fltrs_with_no_obs( hm )
hm$xm
document()
library(menyanthes)
library(devtools)
document()
library(menyanthes)
library(menyanthes)
?menyanthes
documnt()
document()
library(devtools)
document()
library(menyanthes)
